<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis是如何存储数据的</title>
    <url>/2020/09/15/Redis-DataStructure/</url>
    <content><![CDATA[<p>了解Redis的朋友都知道，Redis数据库是以键值对的形式存储所有数据的，Redis还能通过自身支持的五种数据类型来更自由地存储数据，只需要用对应的命令就能以这五种数据类型的形式将数据存进Redis数据库，但是Redis里的具体实现并没有看起来这么简单，这篇文章就自顶向下地来讲讲Redis是如何存储数据的</p>
<h2 id="Redis存储结构"><a href="#Redis存储结构" class="headerlink" title="Redis存储结构"></a>Redis存储结构</h2><p>Redis数据库中键值对数据是以下图的方式存储在Redis服务器的，具体每个结构在下面会逐一分析</p>
<p><img src="/images/redis-storage-structure.jpg" alt="redis-storage-structure.jpg"></p>
<a id="more"></a>

<h3 id="redisServer"><a href="#redisServer" class="headerlink" title="redisServer"></a>redisServer</h3><p>Redis启动时会在main函数中初始化一个redisServer作为Redis服务器的实体，db数组的每一项都是redisDb结构，即Redis数据库，Redis默认是有16个数据库的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    redisDb *db;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> dbnum;                      <span class="comment">/* Total number of configured DBs */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redisDb"><a href="#redisDb" class="headerlink" title="redisDb"></a>redisDb</h3><p>redisDb就是Redis的具体某个数据库，可以用SELECT命令切换当前使用的数据库，redisDb内部有两个dict结构的指针，dict用于存储数据，expires用于存储过期数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>dict内部包含ht数组，存储两个dictht结构，即两个哈希表，ht[0]用于存储数据，ht[1]用于rehash，rehashidx值是用来记录扩容进度的，如果为-1则表示当前没有进行扩容，type属性为dictType结构体，里面包含计算哈希值等几个函数，所以一个Redis数据库的数据存储结构其实就是Redis实现的哈希表</p>
<p>dict进行rehash时会先给ht[1]的表分配内存空间，然后将ht[0]的所有数据重新计算索引值放到h[1]中，再释放ht[0]并将ht[1]的哈希表放到ht[0]，再最后创建一个空的哈希表放到ht[1]，而且为了减小rehash函数对服务器性能造成的影响，Redis没有一次把ht[0]的哈希表数据全部放到ht[1]中，而是渐进式地分多次把数据慢慢地放到ht[1]中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<h3 id="dictht"><a href="#dictht" class="headerlink" title="dictht"></a>dictht</h3><p>dictht内部包含哈希表结构，为一个dictEntry数组，使用链地址法解决哈希冲突，还有表的容量等信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<h3 id="dictEntry"><a href="#dictEntry" class="headerlink" title="dictEntry"></a>dictEntry</h3><p>dictEntry是哈希表的节点，我们存储的每一个键值对都是存储在对应的dictEntry结构中的，dictEntry内部包含了key和value的指针（均为无类型指针），还有一个next指针指向另一个dictEntry，当发生哈希冲突时，可以通过这个指针将冲突的节点组成一条链表解决冲突</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>



<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h3><p>Redis有五种数据类型，分别是String、List、Set、Zset、Hash，但起始Redis实际上并没有实现这五种数据类型，只是定义了五个宏来表示这五种数据类型，因为每一种数据类型都不止一种底层数据结构，所以Redis中的五种数据类型只是一个抽象的概念</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h3><p>Redis实现五种抽象数据类型存储数据的原理其实很简单，就是通过redisObject结构体来存储键值对数据的值，redisObject结构体成员type表示数据类型，encoding表示编码方式，这是Redis具体实现的数据结构，后面会提到，lru表示当前redisObject最后一次被访问的时间，refcount表示当前redisObject被引用的次数，ptr为指向底层存储结构的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>所以redisObject中没有存储数据，只是存储数据的属性和指向底层数据结构的指针，Redis的五种数据类型也只不过是一个属性而已，这样做的好处是Redis可以根据数据的大小灵活地改变底层数据结构，更高效地使用内存空间和存储数据，Redis还能通过redisObject统一地进行数据存储和内存管理、实现共享对象（Redis默认创建0~9999的字符串作为共享对象）</p>
<p><img src="/images/redisObject.jpg" alt="redisObject"></p>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="十种数据编码方式"><a href="#十种数据编码方式" class="headerlink" title="十种数据编码方式"></a>十种数据编码方式</h3><p>Redis存储数据时会根据数据的类型和数据的大小来选择合适的编码方式，每一种编码方式的底层数据结构都是确定的，这里提到的底层数据结构只是简单说明，在后面还会详细分析这些底层数据结构的实现原理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The 'encoding' field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br></pre></td></tr></table></figure>

<h4 id="OBJ-ENCODING-INT"><a href="#OBJ-ENCODING-INT" class="headerlink" title="OBJ_ENCODING_INT"></a>OBJ_ENCODING_INT</h4><p>INT编码方式以整数来保存字符串数据，但是字符串长度得小于或等于20，在tryObjectEncoding函数中，如果字符串长度小于或等于20并且字符串可以非溢出地解析成long值，则会将字符串用long值进行存储，还有如果没有设置maxmemory内存限制的话并且字符串解析的long值小于最小共享值的话会直接返回共享对象（默认创建1~9999为共享对象）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    sds s = o-&gt;ptr;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Check if we can represent this string as a long integer.</span></span><br><span class="line"><span class="comment">     * Note that we are sure that a string larger than 20 chars is not</span></span><br><span class="line"><span class="comment">     * representable as a 32 nor 64 bit integer. */</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">20</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* This object is encodable as a long. Try to use a shared object.</span></span><br><span class="line"><span class="comment">         * Note that we avoid using shared integers when maxmemory is used</span></span><br><span class="line"><span class="comment">         * because every object needs to have a private LRU field for the LRU</span></span><br><span class="line"><span class="comment">         * algorithm to work well. */</span></span><br><span class="line">        <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">            !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;</span><br><span class="line">            value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有设置maxmemory内存限制的话并且字符串解析的long值小于最小共享值</span></span><br><span class="line">            decrRefCount(o);</span><br><span class="line">            incrRefCount(shared.integers[value]);</span><br><span class="line">            <span class="comment">// 返回共享对象</span></span><br><span class="line">            <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) &#123;</span><br><span class="line">                sdsfree(o-&gt;ptr);</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">                o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) &#123;</span><br><span class="line">                decrRefCount(o);</span><br><span class="line">                <span class="keyword">return</span> createStringObjectFromLongLongForValue(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OBJ-ENCODING-EMBSTR"><a href="#OBJ-ENCODING-EMBSTR" class="headerlink" title="OBJ_ENCODING_EMBSTR"></a>OBJ_ENCODING_EMBSTR</h4><p>创建字符串对象时如果字符串长度没有超过44则以EMBSTR编码方式创建，否则以raw编码方式创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从zmalloc函数可以看出redisObject和sds（Redis的字符串结构）是一起分配内存的，他们的地址是连续的，这样可以减少内存分配的次数和避免内存碎片的出现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(struct sdshdr8)+len+<span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr8</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">o</span>+1);</span></span><br><span class="line"></span><br><span class="line">    o-&gt;type = OBJ_STRING;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> (ptr == SDS_NOINIT)</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OBJ-ENCODING-RAW"><a href="#OBJ-ENCODING-RAW" class="headerlink" title="OBJ_ENCODING_RAW"></a>OBJ_ENCODING_RAW</h4><p>当字符串长度大于44时会使用RAW编码方式存储字符串，redisObject和sds是分别申请内存的，然后再将sds的指针赋给redisObject的ptr成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createObject(OBJ_STRING, sdsnewlen(ptr,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sds.c</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OBJ-ENCODING-ZIPLIST"><a href="#OBJ-ENCODING-ZIPLIST" class="headerlink" title="OBJ_ENCODING_ZIPLIST"></a>OBJ_ENCODING_ZIPLIST</h4><p>ZIPLIST编码方式会创建一个ziplist数据结构来存储数据，list、hash、zset类型的数据在成员较少、成员值较小的时候都会采用ziplist的编码方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_LIST,zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_HASH, zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_ZSET,zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个临界值是可以在Redis的配置文件中指定的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> redis.conf</span></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br></pre></td></tr></table></figure>

<h4 id="OBJ-ENCODING-LINKEDLIST"><a href="#OBJ-ENCODING-LINKEDLIST" class="headerlink" title="OBJ_ENCODING_LINKEDLIST"></a>OBJ_ENCODING_LINKEDLIST</h4><p>Redis3.2版本之前，list类型的数据使用LINKEDLIST编码方式，底层为adlist.h中的list数据结构</p>
<h4 id="OBJ-ENCODING-QUICKLIST"><a href="#OBJ-ENCODING-QUICKLIST" class="headerlink" title="OBJ_ENCODING_QUICKLIST"></a>OBJ_ENCODING_QUICKLIST</h4><p>Redis3.2版本之后，list类型的数据使用QUICKLIST编码方式，底层为quicklist.c中quicklist数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"><span class="function">robj *<span class="title">createQuicklistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    quicklist *l = quicklistCreate();</span><br><span class="line">    robj *o = createObject(OBJ_LIST,l);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_QUICKLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OBJ-ENCODING-INTSET"><a href="#OBJ-ENCODING-INTSET" class="headerlink" title="OBJ_ENCODING_INTSET"></a>OBJ_ENCODING_INTSET</h4><p>当set类型的数据都是整数并且数量比较少时会使用INSET编码方式，底层为intset.h中的intset数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = intsetNew();</span><br><span class="line">    robj *o = createObject(OBJ_SET,is);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个临界值同样可以通过Redis的配置文件进行指定</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> redis.conf</span></span><br><span class="line">set-max-intset-entries 512</span><br></pre></td></tr></table></figure>

<h4 id="OBJ-ENCODING-HT"><a href="#OBJ-ENCODING-HT" class="headerlink" title="OBJ_ENCODING_HT"></a>OBJ_ENCODING_HT</h4><p>hash类型的数据使用HT编码方式，底层为dict.h中的dict数据结构，在hashTypeTryConversion函数中检查hash对象，如果存储的字符长度超过临界值，就把ziplist存储结构转换为dict存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// t_hash.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeTryConversion</span><span class="params">(robj *o, robj **argv, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != OBJ_ENCODING_ZIPLIST) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sdsEncodedObject(argv[i]) &amp;&amp;</span><br><span class="line">            sdslen(argv[i]-&gt;ptr) &gt; server.hash_max_ziplist_value)</span><br><span class="line">        &#123;</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set类型的数据也是使用HT编码方式，创建的dict结构的值为NULL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict *d = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">    robj *o = createObject(OBJ_SET,d);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OBJ-ENCODING-SKIPLIST"><a href="#OBJ-ENCODING-SKIPLIST" class="headerlink" title="OBJ_ENCODING_SKIPLIST"></a>OBJ_ENCODING_SKIPLIST</h4><p>zset类型的数据使用SKIPLIST编码方式，底层为zset.h中的zset数据结构，在createZsetObject函数中在创建zset的同时还需要创建一个dict和zskiplist数据结构并将它们的指针赋给zset的成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(OBJ_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>上面说到的数据编码方式使用的对应数据结构都是Redis实际存储值的地方，现在就来看看Redis是怎么实现这些底层数据结构的，dict在一开始介绍Redis存储结构的时候已经提到，这里就略过这个数据结构了</p>
<h4 id="sds"><a href="#sds" class="headerlink" title="sds"></a>sds</h4><p>C语言的char[]数组存储字符串比较局限，所以Redis使用自定义的sds结构体（Simple Dynamic String）来存储字符串，sds结构体中包含字符串长度len，分配的空间大小alloc（已使用和未使用），用于表示结构体类型信息的标志位flags（除了sdshdr5都是低三位表示类型，高五位表示未使用的位），存储字符串的柔性数组buf[]（C语言结构体特性，只是占位符，不占用空间）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sds.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Redis根据字符串长度定义多种sdshdr结构体，比如根据前面的分析可以知道EMBSTR编码方式是直接使用sdshdr8结构体，RAW编码方式是调用sdsnewlen函数根据字符串的长度选择不同类型的结构体来创建字符串，sdshdr5一般不会被用到</p>
<h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h4><p>ziplist是一系列特殊编码的连续内存块组成的顺序型数据结构，用来节约内存，Redis没有定义ziplist的结构体，就是一个unsigned char *，本质上相当于一个字节数组，只定义了宏来表示ziplist内部的各个部分，每个部分的长度也是不同的，ziplist的内存分布： </p>
<p>[zlbytes] [zltail] [zllen] [zlentry] … [zlentry] [zlend]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ziplist.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_END 255</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis定义了ziplist节点的结构体zlentry，但是根据注释了解到这个结构体并不是数据在ziplist的实际编码方式，Redis只是将ziplist中的节点信息按照规则解析到zlentry中，方便后续计算，ziplist节点的内存分布：</p>
<p>[previous_entry_length] [encoding] [content]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ziplist.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize; <span class="comment">/* 用来编码前一节点长度的字节数，就是previous_entry_length的长度 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlen;     <span class="comment">/* 前一节点的长度，就是previous_entry_length的值 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize;        <span class="comment">/* 用来编码节点长度和数据编码信息的字节数，就是encoding的长度 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;            <span class="comment">/* 节点数据的长度，就content的长度 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;      <span class="comment">/* 节点数据编码 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;            <span class="comment">/* 节点数据 */</span></span><br><span class="line">&#125; zlentry;</span><br><span class="line"><span class="comment">/* Return a struct with all information about an entry. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zipEntry</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, zlentry *e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ZIP_DECODE_PREVLEN(p, e-&gt;prevrawlensize, e-&gt;prevrawlen);</span><br><span class="line">    ZIP_DECODE_LENGTH(p + e-&gt;prevrawlensize, e-&gt;encoding, e-&gt;lensize, e-&gt;len);</span><br><span class="line">    e-&gt;headersize = e-&gt;prevrawlensize + e-&gt;lensize;</span><br><span class="line">    e-&gt;p = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list就是一个很基础的双向链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adlist.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><p>quicklist也是一个双向链表，只是它的节点是用ziplist存储数据的（就是下面的unsigned char *），所以节点和链表的基本信息也会比较多</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// quicklist.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can't compress; too small */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">fill</span> : QL_FILL_BITS;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bookmark_count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<h4 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h4><p>intset是一个整数集合，存储结构为contents数组，数组的元素不会重复并且是有序的，contents数组存储的整数类型取决于encoding值，所以只会存储int16_t、int32_t和int64_t类型的整数，intset查看元素是否在集合使用二分查找法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// intset.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"><span class="comment">// intset.s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>

<h4 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h4><p>zskiplist为跳跃表，是一种高效查询的数据结构，元素在表中都是有序的，实现了平均O(logN)，最坏O(N)时间复杂度的查找，是一种空间换时间的实现方式，跳跃表的底层结构就是一个多层链表（zskiplist用数组来构造层），最底层的链表存储完整数据，其他每一层的节点数都不同，是从下层到上层递减的，查找元素的时候是从最上层链表开始并跳跃着往后遍历查找节点，这样就实现了不用遍历位于所查节点前的所有节点就能得到所查节点，有点类似于基于有序数组的二分查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针，用于从后向前遍历</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 用数组实现分层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 每层都有前进指针，用于从前向后遍历</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 节点与前一个节点之间的跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 最大的节点层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p>zset是一个有序的集合，存储的元素都是唯一的，元素根据score值进行排序，Redis用dict和zskiplist都构造zset结构，zskiplist中按照score值从小到大存放了所有集合元素，dict中则是维护了所有集合元素与分值的映射，这是因为同时使用这两种数据结构相比单独使用其中一种数据结构（只使用其中任意一种也可以实现zset的）可以更高效地完成zset的操作，比如查找指定元素的分值（ZSCORE命令）是使用dict的，时间复杂度是O(1)，查找指定范围内的所有元素就用有序的zskiplist，而且zset的dict和zskiplist是共享元素的成员和分值的，所以不会出现重复数据而浪费内存的情况，所以使用这两个数据结构各自的特性完成对应的操作可以最大化zset的性能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p><img src="/images/redis-zset.jpg" alt="redis-zset"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>前后端分离项目中的异常处理</title>
    <url>/2020/02/20/Exception-Handling/</url>
    <content><![CDATA[<p>在前后端分离项目中，系统中的异常不适合直接传递到前端，我们可以用错误码和异常信息封装成的自定义异常类以json的形式发送到前端，前端再根据错误码指定的错误类型和错误信息对用户完成合适的提示，这篇文章就来具体说说怎么去实现这种异常处理方式</p>
<a id="more"></a>

<h2 id="通用返回模型"><a href="#通用返回模型" class="headerlink" title="通用返回模型"></a>通用返回模型</h2><p>为了方便后端向前端传送数据，我们得先实现一个适用所有场景的返回模型，这个模型包含请求的处理结果（成功与否）以及需要返回的数据模型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReturnType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表明对应请求的返回处理结果，success或fail</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// success返回对应VO的json数据，fail则返回通用的错误码格式</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(result, <span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result, String status)</span> </span>&#123;</span><br><span class="line">        CommonReturnType type = <span class="keyword">new</span> CommonReturnType();</span><br><span class="line">        type.setStatus(status);</span><br><span class="line">        type.setData(result);</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个通用返回模型用在Controller中，整个Controller层都可以用这个模型向前端发送数据，然后前端可以解析json获取这个模型，根据响应状态和响应数据完成页面的构建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回的json数据就是&#123;status:"success", data:null&#125;</span></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="业务异常模型"><a href="#业务异常模型" class="headerlink" title="业务异常模型"></a>业务异常模型</h2><p>前面我们说到需要一个用错误码和异常信息封装而成的自定义异常类，那我们可以使用装饰器模式来达到实现业务异常类并且封装业务异常类型的目的</p>
<ul>
<li>首先定义一个核心的错误接口，规范异常类的基本行为，可以获取错误码和错误信息以及覆盖原有的错误信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getErrorMsg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>然后我们实现一个继承了错误接口的枚举类来封装业务异常类型（包含错误码以及错误描述），这里只简单定义了两种通用错误，各个业务模块需要的异常类型也同样可以封装进这个枚举类以供使用，并且实现setErrorMsg方法使枚举对象能够用自定义信息覆盖原始错误信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EmBusinessError implements CommonError &#123;</span><br><span class="line">    <span class="comment">// 通用错误的错误码以及错误描述</span></span><br><span class="line">    UNKNOWN_ERROR(<span class="number">10001</span>, <span class="string">"未知错误"</span>),</span><br><span class="line">    PARAMETER_VALIDATION_ERROR(<span class="number">10002</span>, <span class="string">"参数错误"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EmBusinessError</span><span class="params">(<span class="keyword">int</span> errorCode, String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCode;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>最后我们实现业务异常类，需要实现错误接口并且继承Exception类，我们可以通过构造器直接把EmBusinessError内部的异常类型封装到业务异常类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CommonError commonError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接接收EmBusinessError用于构造业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时接收EmBusinessError和自定义错误信息并覆盖掉原本的错误信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError, String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrorMsg(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.getErrorCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.getErrorMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.setErrorMsg(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>到这里就已经简单地实现了业务异常模型，现在我们可以用前面的通用返回模型来向前端发送异常信息了，而且我们需要一个只存储了异常对象中的错误码和错误信息的Map来作为通用返回模型的数据，这样才可以过滤一些无用的信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BusinessException e = <span class="keyword">new</span> BusinessException(EmBusinessError.UNKNOWN_ERROR);</span><br><span class="line">    Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    data.put(<span class="string">"errorCode"</span>, e.getErrorCode());</span><br><span class="line">    data.put(<span class="string">"errorMsg"</span>, e.getErrorMsg());</span><br><span class="line">    <span class="comment">// 返回的json数据就是&#123;status:"success", data:&#123;errorCode:10001, errorMsg:"未知错误"&#125;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(data, <span class="string">"fail"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>虽然现在已经可以向前端发送系统的异常信息了，但是每次出现异常都需要这样去返回错误信息是真的麻烦，而且系统出现了其他异常还是会直接返回错误页面给前端，这样的结果显然是不合理的，如果可以把异常都抛出，然后实现一个全局异常处理，把异常都拦截下来，再根据不同类型的异常用通用返回模型给前端发送错误信息就好了</p>
<p>好消息是SpringBoot提供的@ControllerAdvice和@ExceptionHandler两个注解可以帮我们实现这种操作，@ExceptionHandler能实现统一处理指定的一类异常，@ControllerAdvice是一种增强的Controller，可以用于定义@ExceptionHandler方法，适用于所有@RequestMapping方法，先看一下代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统一处理所有的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">CommonReturnType</span> <span class="title">doError</span>(<span class="title">Exception</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            BusinessException businessException = (BusinessException)e;</span><br><span class="line">            data.put(<span class="string">"errorCode"</span>, businessException.getErrorCode());</span><br><span class="line">            data.put(<span class="string">"errorMsg"</span>, businessException.getErrorMsg());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> NoHandlerFoundException) &#123;</span><br><span class="line">            data.put(<span class="string">"errorCode"</span>, EmBusinessError.UNKNOWN_ERROR.getErrorCode());</span><br><span class="line">            data.put(<span class="string">"errorMsg"</span>, <span class="string">"没有找到访问路径"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.put(<span class="string">"errorCode"</span>, EmBusinessError.UNKNOWN_ERROR.getErrorCode());</span><br><span class="line">            data.put(<span class="string">"errorMsg"</span>,EmBusinessError.UNKNOWN_ERROR.getErrorMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(data, <span class="string">"fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现了一个全局异常处理类，我们不仅可以处理业务异常，还可以处理404状态的异常以及其他所有的异常，这样前端接收到的永远都是规范的错误信息，我们也就可以放心地在Controller中抛出异常了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">test</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span> Integer id) <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot自动配置原理</title>
    <url>/2020/02/11/SpringBoot-Automatic-Assembly/</url>
    <content><![CDATA[<h2 id="自动配置介绍"><a href="#自动配置介绍" class="headerlink" title="自动配置介绍"></a>自动配置介绍</h2><p>使用Spring框架时，项目中需要的组件都要在配置文件中或者配置类进行注册导入容器，而在使用Spring Boot框架时，常用的组件都不再需要手动配置才能使用，主程序启动时会自动把所有用到的组件导入容器中，如果想要修改组件的默认配置，在Spring Boot主配置文件Application.properties中配置对应的属性即可。</p>
<p>Spring Boot启动时自动导入组件是主程序中<strong>@SpringBootApplication</strong>注解实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">    <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">    @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p><strong>@SpringBootConfiguration</strong>是Spring Boot的配置类注解，内部由<strong>@Configuration</strong>标注，表明标注的类是Spring Boot的主配置类，运行此类的main方法来启动整个应用</p>
<p><strong>@EnableAutoConfiguration</strong>是开启自动配置功能的注解，内部由两个注解标注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解<strong>@AutoConfigurationPackage</strong>是自动配置组件包的注解，由<strong>@Import</strong>导入组件Registrar.class，该组件会获取主配置类所在的包路径，然后将包和子包中所有组件扫描到容器中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Registrar<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Import({EnableAutoConfigurationImportSelector.class})导入自动配置类选择器，选择器将返回所有需要的组件的自动配置类的全类名组成的数组，Import注解就会把这些自动配置类添加到容器中，这些自动配置类生效后会把对应的组件导入到容器中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// EnableAutoConfigurationImportSelector.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">       Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">       <span class="keyword">return</span> configurations;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>SpringFactoriesLoader.<strong>loadFactoryNames</strong>方法会扫描所有jar包类路径下的<strong>META-INF/spring.factories</strong>文件中获取自动配置类的全类名，然后这些自动配置类全部被导入容器，进行自动配置工作</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring-boot-autoconfigure-1.5.9.RELEASE.jar下META-INF/spring.factories</span></span><br><span class="line"><span class="comment"># Initializers</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Listeners</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span></span><br><span class="line"><span class="attr">...</span></span><br></pre></td></tr></table></figure>



<h2 id="自动配置类原理"><a href="#自动配置类原理" class="headerlink" title="自动配置类原理"></a>自动配置类原理</h2><p>Spring Boot通过@SpringBootConfiguration注解就能把项目的组件和常用组件的自动配置类都导入容器中，那么自动配置类是如何将组件导入容器的，就以<strong>HttpEncodingAutoConfiguration</strong>自动配置类为例说明一下自动配置类的原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HttpEncodingAutoConfiguration.java</span></span><br><span class="line"><span class="comment">// 表示配置类，可以给容器添加组件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//启动指定类的ConfigurationProperties功能，会将配置文件中对应的值和HttpEncodingProperties属性绑定，并把该类导入到IOC容器</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;HttpProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">// <span class="title">Spring</span>底层注解<span class="title">Conditional</span>，根据不同的条件，如果满足指定条件，整个配置类生效</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span></span></span><br><span class="line"><span class="class">// 判断当前项目有无此类</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(</span>&#123;CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">// 判断是否存在该配置（<span class="title">spring</span>.<span class="title">http</span>.<span class="title">encoding</span>.<span class="title">enabled</span>），不配置默认为<span class="title">true</span></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>,value = &#123;<span class="string">"enabled"</span>&#125;,matchIfMissing=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器注入依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器添加组件CharacterEncodingFilter，组件需要的值从properties中获取，即HttpEncodingProperties</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 容器中没有该组件就自动加载，可以自定义</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(&#123;CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">CharacterEncodingFilter</span> <span class="title">characterEncodingFilter</span>() </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>*Properties.class</strong>都是组件属性和配置文件映射的类，这些类中封装着组件能配置的属性，@EnableConfigurationProperties({HttpProperties.class})就是把配置文件中HttpEncoding组件的属性绑定到HttpProperties.class的对应属性中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从配置文件中获取指定的值bean的属性进行绑定</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>高并发场景下RocketMq实现Redis缓存和MySQL数据库的一致性</title>
    <url>/2020/03/03/Mq-Cache-DB-Consistency/</url>
    <content><![CDATA[<p><img src="/images/RocketMQ-Transaction.jpg" alt="RocketMQ-Transaction"></p>
]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
  </entry>
  <entry>
    <title>简析Spring的IOC容器机制</title>
    <url>/2020/05/29/Spring-ClassPathXmlApplicationContext/</url>
    <content><![CDATA[<h2 id="Spring的容器"><a href="#Spring的容器" class="headerlink" title="Spring的容器"></a>Spring的容器</h2><p>我们在启动Spring的时候首先得起个容器，通过xml配置文件来得到一个Spring容器是一个很常见的操作，还有两个常用的容器为FileSystemXmlApplicationContext和AnnotationConfigApplicationContext，这三个容器都实现类ApplicationContext这个接口，这个接口构造的容器，会采取立即加载和创建Bean的机制，即读取完配置文件后直接创建配置文件中配置的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:application.xml"</span>);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="容器类的继承关系"><a href="#容器类的继承关系" class="headerlink" title="容器类的继承关系"></a>容器类的继承关系</h2><p>先来看用来构造容器的接口ApplicationContext接口的子类关系图，三个常用容器实现类都处于ApplicationContext接口继承关系的底层，FileSystemXmlApplicationContext和ClassPathXmlApplicationContext为同一类，都需要xml配置文件，而AnnotationConfigApplicationContext则处于另一个分支，不需要配置文件</p>
<p><img src="/images/ApplicationContext.png" alt="Application"></p>
<p>但是ApplicationContext不是Spring容器的顶层接口，Spring容器最顶层的接口为BeanFactory，ApplicationContext也只是BeanFactory的一个子接口，BeanFactory负责生产和管理各个Bean实例，它有三大子接口，分别为ListableBeanFactory（可以枚举工厂生产的所有Bean实例）、HierarchicalBeanFactory（实现工厂分层，可以返回父工厂）、AutowireCapableBeanFactory（实现对容器中实例的管理，负责自动装配Bean）</p>
<p><img src="/images/BeanFactory.png" alt="BeanFactory"></p>
<p>从继承关系中可以看到ApplicationContext只实现了ListableBeanFactory和HierarchicalBeanFactory，并没有实现AutowireCapableBeanFactory接口，而是在内部以组合的方式集成了AutowireCapableBeanFactory的功能，通过简析ClassPathXmlApplicationContext实现原理就能解答这个问题，并且初步窥探Spring容器的机制</p>
<p>我们创建ClassPathXmlApplicationContext时构造器简单来说干了两件最主要的事，分别是BeanFactory的初始化和Bean的初始化，完成后便返回构造好的ClassPathXmlApplicationContext对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// 初始化BeanFactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        ...</span><br><span class="line">            <span class="comment">// 初始化所有的Bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BeanFactory初始化"><a href="#BeanFactory初始化" class="headerlink" title="BeanFactory初始化"></a>BeanFactory初始化</h2><p>BeanFactory的初始化是在obtainFreshBeanFactory()方法中完成的，BeanFactory初始化的过程包括创建BeanFactory、从配置文件加载Bean和把Bean注册到BeanFactory中，而且值得一提的是在这个方法中，如果已经启动了BeanFactory就会关闭，然后再重新进行BeanFactory初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 创建一个DefaultListableBeanFactory实例</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 加载并注册Bean</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="comment">// 把DefaultListableBeanFactory组合到当前ClassPathXmlApplicationContext对象中</span></span><br><span class="line">        	<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以看出，ApplicationContext并不是自己直接存储Bean，而是持有一个BeanFactory接口最底层的一个实现类DefaultListableBeanFactory，这个类同时实现了BeanFactory三大子接口，具备所有扩展功能，所以ApplicationContext是用它来存储Bean的</p>
<p>实例化BeanFactory后就调用loadBeanDefinitions()把Bean从配置文件中加载到并注册到容器中，这里只是注册，并没有对Bean进行实例化，这个方法的过程非常复杂，首先通过解析xml配置文件把配置的Bean变成BeanDefinition，这个类存储很多关于Bean的信息，把Bean注册到BeanFactory就是把其对应的BeanDefinition存储到BeanFactory中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册Bean核心操作没有特别复杂，以BeanName为key，BeanDefinition为value存入DefaultListableBeanFactory持有的BeanDefinitionMap中即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	...</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    	<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此BeanFactory初始化就已经完成，在初始化的过程中ApplicationContext持有一个实例化的DefaultListableBeanFactory，并且从配置文件中读取到所有的Bean信息封装成BeanDefinition并存入到容器的Map中以此作为注册操作</p>
<h2 id="Bean初始化"><a href="#Bean初始化" class="headerlink" title="Bean初始化"></a>Bean初始化</h2><p>前面调用的finishBeanFactoryInitialization方法会初始化所有的Singleton Bean，Bean的实例化就是在这个步骤中完成的，除了实例化Bean，这个方法里还进行了很多操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后其实是调用了ApplicationContext持有的DefaultListableBeanFactory对象的方法来初始化单例Bean的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 前面注册Bean的时候把所有的BeanName加入到了beanDefinitionNames的list中</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        ...</span><br><span class="line">            getBean(beanName);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过曲折地调用路径终于来到了一个熟悉的方法，就是我们用来获取容器中Bean对象的方法getBean()，进入这个方法，如果需要的Bean已经初始化就直接返回，如果没有则先进行初始化操作再返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Object bean;</span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	...</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    	<span class="comment">// 上面都是确认一下Bean有没有初始化，下面就是开始初始化Bean了</span></span><br><span class="line">    	<span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    	...</span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        	sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">            	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                	<span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                    	destroySingleton(beanName);</span><br><span class="line">                     	<span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> (T) Bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面调用的createBean()方法是AbstractAutowireCapableBeanFactory中实现的，最终调用doCreateBean()方法，Spring Bean生命周期中的事例创建和Bean初始化两个阶段都是在这完成的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">	BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建Bean实例</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 属性装配</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    	<span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化回调</span></span><br><span class="line">        	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doCreateBean()方法运行完后Bean的初始化就已经完成了，当所有的Bean完成初始化，构造容器最主要的两步完成，refresh()方法中再进行一些剩余的操作，就能得到一个ClassPathXmlApplicationContext实例对象进行Spring容器的操作了。</p>
<h2 id="初始化Bean时的回调"><a href="#初始化Bean时的回调" class="headerlink" title="初始化Bean时的回调"></a>初始化Bean时的回调</h2><p>值得一提的是上面doCreateBean()方法调用的initializeBean()方法是为了实现Bean配置中的各种初始化回调的，比如Aware相关接口，BeanPostProcessor处理， InitializingBean接口或者配置init-method等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 如果有实现Aware相关接口</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 如果有BeanPostProcessor的postProcessBeforeInitialization 回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 如果有实现InitializingBean接口或者配置了init-method</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 如果有BeanPostProcessor的postProcessAfterInitialization 回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadLocal是怎么实现线程私有变量的</title>
    <url>/2020/06/08/ThreadLocal/</url>
    <content><![CDATA[<h2 id="ThreadLocal的功能"><a href="#ThreadLocal的功能" class="headerlink" title="ThreadLocal的功能"></a>ThreadLocal的功能</h2><p>在JMM中，所有的对象都存储在堆中，每个线程都能去访问堆中的对象，如果要暂时占有对象，可以使用Synchronized关键字进行加锁操作，但是这种操作只是暂时的，线程释放了锁以后这个对象又会变成共享状态。如果遇到需要生成线程私有变量的场景时，Java提供了一个叫ThreadLocal的类，用来构造线程独享的对象</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; localInstance = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                        Integer n = localInstance.get();</span><br><span class="line">                        localInstance.set(++n);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">------输出------</span></span><br><span class="line"><span class="comment">Thread-0 1</span></span><br><span class="line"><span class="comment">Thread-0 2</span></span><br><span class="line"><span class="comment">Thread-1 1</span></span><br><span class="line"><span class="comment">Thread-1 2</span></span><br><span class="line"><span class="comment">Thread-2 1</span></span><br><span class="line"><span class="comment">Thread-2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在这个程序运行过程中，尽管有3个线程在对类变量localInstance进行操作，但是每个线程之间的操作是独立的，并没有累加在一起，所以通过ThreadLocal构造的变量是可以保证线程私有的</p>
<h2 id="ThreadLocal的内部实现机制"><a href="#ThreadLocal的内部实现机制" class="headerlink" title="ThreadLocal的内部实现机制"></a>ThreadLocal的内部实现机制</h2><p>先来看ThreadLocal最基本的set和get方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 然后根据ThreadLocal对象自己找到map中的Entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">	t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管是set还是get方法都是对一个ThreadLocalMap的对象进行操作，get时以自身为key去Map中取出变量，set时以自身为key，变量为value存进Map中。这里面的ThreadLocalMap是ThreadLocal的一个内部类，为整个机制的核心，因为每个线程的ThreadLocal变量和其对应的私有变量是以键值对的形式存储在ThreadLocalMap中，所以ThreadLocal相当于在ThreadLocalMap的基础上再封装了一层操作。而获取这个map时要传入当前线程对象是因为每个线程对象都持有一个ThreadLocalMap（threadLocals变量），存储着线程自己的私有变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这，线程私有变量实现机制便已经有了答案，前面测试程序中每个线程调用localInstance的get方法时，虽然操作的是同一个类变量，但get方法内部都是去线程自己的ThreadLocalMap中取出来的变量，调用set方法时也是在方法内部把变量存进线程自己的ThreadLocalMap中，这样的话每个线程真正操作的变量自然都是互相独立的</p>
<p><img src="/images/ThreadLocal.jpg" alt="ThreadLocal"></p>
<h2 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h2><p>ThreadLocaMap的Entry是继承了WeakReference的，把Map的key声明为了虚引用，虚引用的作用就是当没有强引用关联该对象时如果遇到GC就会被回收，举个简单的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">WeakReference&lt;String&gt; n = <span class="keyword">new</span> WeakReference&lt;String&gt;(s);</span><br><span class="line">System.out.println(n.get());</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(n.get());</span><br><span class="line"><span class="comment">/*---输出---</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>所以当Entry的key没有被强引用关联时就会被垃圾回收，因为ThreadLocalMap生命周期是与线程一致的，如果不再需要使用ThreadLocal对象并且ThreadLocalMap对ThreadLocal对象时强引用的情况下，ThreadLocal对象是不会被回收的，造成了内存泄漏的问题，所以Entry的key被声明为了虚引用，当不再被外部强引用时就会回收</p>
<p>但是这样又产生了新的问题，就是Entry中key被回收了以后，value还是继续存在吗，实践是检验真理的唯一标准，实现一个测试的环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localInstance = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">        WeakReference&lt;ThreadLocal&gt; r = <span class="keyword">new</span> WeakReference&lt;ThreadLocal&gt;(localInstance);</span><br><span class="line">        localInstance.set(s);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread t = Thread.currentThread();</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            localInstance = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Debug运行，第一轮循环ThreadLocalMap存储着”string”字符串对象，WeakReference对象指向ThreadLocal对象</p>
<p><img src="/images/ThreadLocal1.png" alt="ThreadLocal1"></p>
<p>第二轮循环，WeakReference对象指向空，所以经过上一次GC后ThreadLocal对象已经被回收了，但是ThreadLocalMap还是存储着”string”字符串对象</p>
<p><img src="/images/ThreadLocal2.png" alt="ThreadLocal2"></p>
<p>针对这种情况，其实ThreadLocalMap有实现解决的机制，cleanSomeSlots()方法、expungeStaleEntry()方法和replaceStaleEntry()方法都是为了解决ThreadLocalMap潜在的内存泄漏问题的</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>三步实现简易的IOC</title>
    <url>/2020/06/21/IOC-achieve/</url>
    <content><![CDATA[<p>IOC（Inversion Of Control）是一种设计思想，意思是控制反转，这个思想的目的是为了自动地管理类的生命周期以及所有类之间的依赖关系。传统Java SE程序中如果我们需要在一个实例中引用另一个对象，一般是直接用new关键字直接创建一个对象来构建这个依赖关系，这种依赖构建方式使程序之间具有很强的耦合关系，甚至程序不能独立编译，难以进行单元测试。IOC设计思想可以让我们实现程序之间的解耦，很大程度地提高程序的灵活性和可维护性。以前是对象控制其他对象，现在将所有对象的控制权都交给了IOC实现组件，所以称为控制反转。</p>
<a id="more"></a>

<p>那么怎么去实现IOC设计思想呢，IOC有两个比较重要的概念，一个是容器，一个是DI（Dependency Injection，依赖注入）。容器的任务是管理类的生命周期，DI的任务是创建容器中各个类之间的依赖关系。我们只需要实现这两个核心概念就可以实现一个简易的IOC组件。</p>
<h2 id="配置约定"><a href="#配置约定" class="headerlink" title="配置约定"></a>配置约定</h2><p>虽然IOC组件可以使我们不用手动地管理类和他们之间的依赖关系，但是我们还是需要通过配置的方式来使IOC组件根据我们的需要去管理所有的类，所以首先得约定好如何进行配置来使我们的需求被IOC组件识别，这里为了简单实现选择注解这个配置方式</p>
<ul>
<li>把当前类加入容器的注解@Bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为实例变量注入依赖的注解@Autowired</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类扫描器"><a href="#类扫描器" class="headerlink" title="类扫描器"></a>类扫描器</h2><p>在实现容器之前，我们需要拿到项目中所有的类，为了后面创建容器时能从这些类中获取带有@Bean注解的类加入容器。我们首先用ClassLoader类的getResources()方法获取包的根文件夹下的资源，然后根据这些资源是文件还是Jar包对资源做对应的处理，如果是文件就是树状读取，使用递归的方式获取文件下所有类的全类名，如果使Jar包就进行解析操作，然后迭代获取Jar包中的所有类的全类名，根据拿到的全类名通过反射的方式拿到所有类的Class对象存入list后最后返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassScanner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;?&gt;&gt; getClassList() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 除了第一次都不要需要扫描，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; classList = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Enumeration&lt;URL&gt; urls = loader.getResources(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            String protocol = url.getProtocol();</span><br><span class="line">            <span class="keyword">if</span> (protocol.equals(<span class="string">"file"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 在class目录中</span></span><br><span class="line">                String packagePath = url.getPath();</span><br><span class="line">                <span class="comment">// 执行添加类操作</span></span><br><span class="line">                addClass(classList, packageName, packagePath);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"jar"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 在jar包中</span></span><br><span class="line">                JarURLConnection jarURLConnection = (JarURLConnection) url.openConnection();</span><br><span class="line">                JarFile jarFile = jarURLConnection.getJarFile();</span><br><span class="line">                Enumeration&lt;JarEntry&gt; jarEntries = jarFile.entries();</span><br><span class="line">                <span class="keyword">while</span> (jarEntries.hasMoreElements()) &#123;</span><br><span class="line">                    JarEntry jarEntry = jarEntries.nextElement();</span><br><span class="line">                    String jarEntryName = jarEntry.getName();</span><br><span class="line">                    <span class="comment">// 判断entry是否为class</span></span><br><span class="line">                    <span class="keyword">if</span> (jarEntryName.endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 获取类名</span></span><br><span class="line">                        String className = jarEntryName.substring(<span class="number">0</span>, jarEntryName.lastIndexOf(<span class="string">"."</span>)).replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">                        <span class="comment">// 执行添加类操作</span></span><br><span class="line">                        addClass(classList, className);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扫描完成后保存list</span></span><br><span class="line">        <span class="keyword">this</span>.list = classList;</span><br><span class="line">        <span class="keyword">return</span> classList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getClassBySuper(Class&lt;?&gt; superClass) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : list) &#123;</span><br><span class="line">            <span class="comment">// 如果是superClass的子类就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (superClass.isAssignableFrom(clazz) &amp;&amp; superClass != clazz) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClass</span><span class="params">(List&lt;Class&lt;?&gt;&gt; classList, <span class="keyword">final</span> String packageName, String packagePath)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只获取包路径下的class文件和目录</span></span><br><span class="line">        File[] files = <span class="keyword">new</span> File(packagePath).listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (pathname.isFile() &amp;&amp; pathname.getName().endsWith(<span class="string">".class"</span>) || pathname.isDirectory());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            String fileName = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                <span class="comment">// 文件</span></span><br><span class="line">                String className = fileName.substring(<span class="number">0</span>, fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">                className = packageName + <span class="string">"."</span> + className;</span><br><span class="line">                addClass(classList, className);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 目录</span></span><br><span class="line">                <span class="comment">// 子目录名</span></span><br><span class="line">                String subPackagePath = packagePath + <span class="string">"/"</span> + fileName;</span><br><span class="line">                <span class="comment">// 子包名</span></span><br><span class="line">                String subPackageName = packageName + <span class="string">"."</span> + fileName;</span><br><span class="line">                <span class="comment">// 递归文件夹</span></span><br><span class="line">                addClass(classList, subPackageName, subPackagePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClass</span><span class="params">(List&lt;Class&lt;?&gt;&gt; classList, String className)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">        clazz = Class.forName(className, <span class="keyword">false</span>, Thread.currentThread().getContextClassLoader());</span><br><span class="line">        classList.add(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>对于容器我们可以直接使用静态加载的方式来简单创建一个HashMap来存储需要管理的实例，通过前面实现的类扫描器拿到的所有类的Class对象并识别带有@Bean注解的类，通过反射的方式实例化这个类，最后以Class对象为key，实例对象为value存入HashMap中，创建容器完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; beanMap = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassScanner classScanner = <span class="keyword">new</span> ClassScanner();</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; classList = classScanner.getClassList();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; clazz : classList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(Bean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 将有Bean注解的类实例化</span></span><br><span class="line">                    Object beanInstance = clazz.newInstance();</span><br><span class="line">                    <span class="comment">// 把创建的实例放入BeanMap中</span></span><br><span class="line">                    beanMap.put(clazz, beanInstance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把ClassScanner对象注入容器，供后续使用</span></span><br><span class="line">            beanMap.put(ClassScanner<span class="class">.<span class="keyword">class</span>, <span class="title">classScanner</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"容器创建出现错误"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!beanMap.containsKey(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"容器中没有此实例"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) beanMap.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> beanMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>实现容器后类的创建已经不用我们来考虑了，我们只需要实现依赖注入就完成实现IOC组件的最后一步了。为了简单实现，还是使用静态加载的方式实现这个功能。获取容器中所有Bean，然后找到Bean中带有@Aotuwired注解的字段，然后通过反射的方式进行字段注入。而且需要考虑一种比较特殊的情况，就是如果需要依赖注入的字段为接口时，我们需要去找到接口的实现类再进行注入，前面实现的类扫描器也提供了获取接口实现类的方法，使用反射的API判断得到接口的实现类，简单实现拿到第一个实现类就返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInjection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;Class&lt;?&gt;, Object&gt; beanMap = ApplicationContext.getBeanMap();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123;</span><br><span class="line">                <span class="comment">// 获取Bean的Class对象和实例</span></span><br><span class="line">                Class&lt;?&gt; beanClass = beanEntry.getKey();</span><br><span class="line">                Object beanInstance = beanEntry.getValue();</span><br><span class="line">                <span class="comment">// 获取Bean中的所有字段</span></span><br><span class="line">                Field[] fields = beanClass.getDeclaredFields();</span><br><span class="line">                <span class="keyword">if</span> (ArrayUtils.isNotEmpty(fields)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                        <span class="comment">// 找到带有Autowired注解的字段执行注入操作</span></span><br><span class="line">                        <span class="keyword">if</span> (field.isAnnotationPresent(Autowired<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                            <span class="comment">// 获取字段的Class对象</span></span><br><span class="line">                            Class&lt;?&gt; clazz = field.getType();</span><br><span class="line">                            <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                                <span class="comment">// 获取字段对应的实现类</span></span><br><span class="line">                                Class&lt;?&gt; implClass = getImpl(clazz);</span><br><span class="line">                                <span class="comment">// 获取注入对象</span></span><br><span class="line">                                Object injectInstance = beanMap.get(implClass);</span><br><span class="line">                                <span class="comment">// 暴力注入</span></span><br><span class="line">                                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                                field.set(beanInstance, injectInstance);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                Object injectInstance = beanMap.get(clazz);</span><br><span class="line">                                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                                field.set(beanInstance, injectInstance);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"依赖注入出现错误"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取接口的实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getImpl(Class&lt;?&gt; superClass) &#123;</span><br><span class="line">        ClassScanner classScanner = ApplicationContext.getBean(ClassScanner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Class&lt;?&gt; implClass = classScanner.getClassBySuper(superClass);</span><br><span class="line">        <span class="keyword">if</span> (implClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> implClass;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"注入字段为没有实现类的接口"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件初始化"><a href="#组件初始化" class="headerlink" title="组件初始化"></a>组件初始化</h2><p>因为容器和DI都是静态加载实现的，所以实现组件时直接进行两次类加载就可以完成组件的初始化，需要注意的是必须先加载容器再进行依赖注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCStarter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class.forName(ApplicationContext<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        Class.forName(DependencyInjection<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
