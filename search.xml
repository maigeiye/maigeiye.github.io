<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>高并发场景下RocketMq实现Redis缓存和MySQL数据库的一致性</title>
    <url>/2020/03/03/Mq-Cache-DB-Consistency/</url>
    <content><![CDATA[<p><img src="/images/RocketMQ-Transaction.jpg" alt="RocketMQ-Transaction"></p>
]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
  </entry>
  <entry>
    <title>前后端分离项目中的异常处理</title>
    <url>/2020/02/20/Exception-Handling/</url>
    <content><![CDATA[<p>在前后端分离项目中，系统中的异常不适合直接传递到前端，我们可以用错误码和异常信息封装成的自定义异常类以json的形式发送到前端，前端再根据错误码指定的错误类型和错误信息对用户完成合适的提示，这篇文章就来具体说说怎么去实现这种异常处理方式</p>
<a id="more"></a>

<h2 id="通用返回模型"><a href="#通用返回模型" class="headerlink" title="通用返回模型"></a>通用返回模型</h2><p>为了方便后端向前端传送数据，我们得先实现一个适用所有场景的返回模型，这个模型包含请求的处理结果（成功与否）以及需要返回的数据模型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReturnType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表明对应请求的返回处理结果，success或fail</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// success返回对应VO的json数据，fail则返回通用的错误码格式</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(result, <span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result, String status)</span> </span>&#123;</span><br><span class="line">        CommonReturnType type = <span class="keyword">new</span> CommonReturnType();</span><br><span class="line">        type.setStatus(status);</span><br><span class="line">        type.setData(result);</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个通用返回模型用在Controller中，整个Controller层都可以用这个模型向前端发送数据，然后前端可以解析json获取这个模型，根据响应状态和响应数据完成页面的构建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回的json数据就是&#123;status:"success", data:null&#125;</span></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="业务异常模型"><a href="#业务异常模型" class="headerlink" title="业务异常模型"></a>业务异常模型</h2><p>前面我们说到需要一个用错误码和异常信息封装而成的自定义异常类，那我们可以使用装饰器模式来达到实现业务异常类并且封装业务异常类型的目的</p>
<ul>
<li>首先定义一个核心的错误接口，规范异常类的基本行为，可以获取错误码和错误信息以及覆盖原有的错误信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getErrorMsg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>然后我们实现一个继承了错误接口的枚举类来封装业务异常类型（包含错误码以及错误描述），这里只简单定义了两种通用错误，各个业务模块需要的异常类型也同样可以封装进这个枚举类以供使用，并且实现setErrorMsg方法使枚举对象能够用自定义信息覆盖原始错误信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EmBusinessError implements CommonError &#123;</span><br><span class="line">    <span class="comment">// 通用错误的错误码以及错误描述</span></span><br><span class="line">    UNKNOWN_ERROR(<span class="number">10001</span>, <span class="string">"未知错误"</span>),</span><br><span class="line">    PARAMETER_VALIDATION_ERROR(<span class="number">10002</span>, <span class="string">"参数错误"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EmBusinessError</span><span class="params">(<span class="keyword">int</span> errorCode, String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCode;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>最后我们实现业务异常类，需要实现错误接口并且继承Exception类，我们可以通过构造器直接把EmBusinessError内部的异常类型封装到业务异常类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CommonError commonError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接接收EmBusinessError用于构造业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时接收EmBusinessError和自定义错误信息并覆盖掉原本的错误信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError, String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrorMsg(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.getErrorCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.getErrorMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.setErrorMsg(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>到这里就已经简单地实现了业务异常模型，现在我们可以用前面的通用返回模型来向前端发送异常信息了，而且我们需要一个只存储了异常对象中的错误码和错误信息的Map来作为通用返回模型的数据，这样才可以过滤一些无用的信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BusinessException e = <span class="keyword">new</span> BusinessException(EmBusinessError.UNKNOWN_ERROR);</span><br><span class="line">    Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    data.put(<span class="string">"errorCode"</span>, e.getErrorCode());</span><br><span class="line">    data.put(<span class="string">"errorMsg"</span>, e.getErrorMsg());</span><br><span class="line">    <span class="comment">// 返回的json数据就是&#123;status:"success", data:&#123;errorCode:10001, errorMsg:"未知错误"&#125;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(data, <span class="string">"fail"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>虽然现在已经可以向前端发送系统的异常信息了，但是每次出现异常都需要这样去返回错误信息是真的麻烦，而且系统出现了其他异常还是会直接返回错误页面给前端，这样的结果显然是不合理的，如果可以把异常都抛出，然后实现一个全局异常处理，把异常都拦截下来，再根据不同类型的异常用通用返回模型给前端发送错误信息就好了</p>
<p>好消息是SpringBoot提供的@ControllerAdvice和@ExceptionHandler两个注解可以帮我们实现这种操作，@ExceptionHandler能实现统一处理指定的一类异常，@ControllerAdvice是一种增强的Controller，可以用于定义@ExceptionHandler方法，适用于所有@RequestMapping方法，先看一下代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统一处理所有的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">CommonReturnType</span> <span class="title">doError</span>(<span class="title">Exception</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            BusinessException businessException = (BusinessException)e;</span><br><span class="line">            data.put(<span class="string">"errorCode"</span>, businessException.getErrorCode());</span><br><span class="line">            data.put(<span class="string">"errorMsg"</span>, businessException.getErrorMsg());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> NoHandlerFoundException) &#123;</span><br><span class="line">            data.put(<span class="string">"errorCode"</span>, EmBusinessError.UNKNOWN_ERROR.getErrorCode());</span><br><span class="line">            data.put(<span class="string">"errorMsg"</span>, <span class="string">"没有找到访问路径"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.put(<span class="string">"errorCode"</span>, EmBusinessError.UNKNOWN_ERROR.getErrorCode());</span><br><span class="line">            data.put(<span class="string">"errorMsg"</span>,EmBusinessError.UNKNOWN_ERROR.getErrorMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(data, <span class="string">"fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现了一个全局异常处理类，我们不仅可以处理业务异常，还可以处理404状态的异常以及其他所有的异常，这样前端接收到的永远都是规范的错误信息，我们也就可以放心地在Controller中抛出异常了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">test</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span> Integer id) <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot自动配置原理</title>
    <url>/2020/02/11/SpringBoot-Automatic-Assembly/</url>
    <content><![CDATA[<h2 id="自动配置介绍"><a href="#自动配置介绍" class="headerlink" title="自动配置介绍"></a>自动配置介绍</h2><p>使用Spring框架时，项目中需要的组件都要在配置文件中或者配置类进行注册导入容器，而在使用Spring Boot框架时，常用的组件都不再需要手动配置才能使用，主程序启动时会自动把所有用到的组件导入容器中，如果想要修改组件的默认配置，在Spring Boot主配置文件Application.properties中配置对应的属性即可。</p>
<p>Spring Boot启动时自动导入组件是主程序中<strong>@SpringBootApplication</strong>注解实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">    <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">    @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p><strong>@SpringBootConfiguration</strong>是Spring Boot的配置类注解，内部由<strong>@Configuration</strong>标注，表明标注的类是Spring Boot的主配置类，运行此类的main方法来启动整个应用</p>
<p><strong>@EnableAutoConfiguration</strong>是开启自动配置功能的注解，内部由两个注解标注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解<strong>@AutoConfigurationPackage</strong>是自动配置组件包的注解，由<strong>@Import</strong>导入组件Registrar.class，该组件会获取主配置类所在的包路径，然后将包和子包中所有组件扫描到容器中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Registrar<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Import({EnableAutoConfigurationImportSelector.class})导入自动配置类选择器，选择器将返回所有需要的组件的自动配置类的全类名组成的数组，Import注解就会把这些自动配置类添加到容器中，这些自动配置类生效后会把对应的组件导入到容器中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// EnableAutoConfigurationImportSelector.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">       Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">       <span class="keyword">return</span> configurations;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>SpringFactoriesLoader.<strong>loadFactoryNames</strong>方法会扫描所有jar包类路径下的<strong>META-INF/spring.factories</strong>文件中获取自动配置类的全类名，然后这些自动配置类全部被导入容器，进行自动配置工作</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring-boot-autoconfigure-1.5.9.RELEASE.jar下META-INF/spring.factories</span></span><br><span class="line"><span class="comment"># Initializers</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Listeners</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span></span><br><span class="line"><span class="attr">...</span></span><br></pre></td></tr></table></figure>



<h2 id="自动配置类原理"><a href="#自动配置类原理" class="headerlink" title="自动配置类原理"></a>自动配置类原理</h2><p>Spring Boot通过@SpringBootConfiguration注解就能把项目的组件和常用组件的自动配置类都导入容器中，那么自动配置类是如何将组件导入容器的，就以<strong>HttpEncodingAutoConfiguration</strong>自动配置类为例说明一下自动配置类的原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HttpEncodingAutoConfiguration.java</span></span><br><span class="line"><span class="comment">// 表示配置类，可以给容器添加组件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//启动指定类的ConfigurationProperties功能，会将配置文件中对应的值和HttpEncodingProperties属性绑定，并把该类导入到IOC容器</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;HttpProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">// <span class="title">Spring</span>底层注解<span class="title">Conditional</span>，根据不同的条件，如果满足指定条件，整个配置类生效</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span></span></span><br><span class="line"><span class="class">// 判断当前项目有无此类</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(</span>&#123;CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">// 判断是否存在该配置（<span class="title">spring</span>.<span class="title">http</span>.<span class="title">encoding</span>.<span class="title">enabled</span>），不配置默认为<span class="title">true</span></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>,value = &#123;<span class="string">"enabled"</span>&#125;,matchIfMissing=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器注入依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器添加组件CharacterEncodingFilter，组件需要的值从properties中获取，即HttpEncodingProperties</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 容器中没有该组件就自动加载，可以自定义</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(&#123;CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">CharacterEncodingFilter</span> <span class="title">characterEncodingFilter</span>() </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>*Properties.class</strong>都是组件属性和配置文件映射的类，这些类中封装着组件能配置的属性，@EnableConfigurationProperties({HttpProperties.class})就是把配置文件中HttpEncoding组件的属性绑定到HttpProperties.class的对应属性中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从配置文件中获取指定的值bean的属性进行绑定</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>三步实现简易的IOC</title>
    <url>/2020/06/21/IOC-achieve/</url>
    <content><![CDATA[<p>IOC（Inversion Of Control）是一种设计思想，意思是控制反转，这个思想的目的是为了自动地管理类的生命周期以及所有类之间的依赖关系。传统Java SE程序中如果我们需要在一个实例中引用另一个对象，一般是直接用new关键字直接创建一个对象来构建这个依赖关系，这种依赖构建方式使程序之间具有很强的耦合关系，甚至程序不能独立编译，难以进行单元测试。IOC设计思想可以让我们实现程序之间的解耦，很大程度地提高程序的灵活性和可维护性。以前是对象控制其他对象，现在将所有对象的控制权都交给了IOC实现组件，所以称为控制反转。</p>
<a id="more"></a>

<p>那么怎么去实现IOC设计思想呢，IOC有两个比较重要的概念，一个是容器，一个是DI（Dependency Injection，依赖注入）。容器的任务是管理类的生命周期，DI的任务是创建容器中各个类之间的依赖关系。我们只需要实现这两个核心概念就可以实现一个简易的IOC组件。</p>
<h2 id="配置约定"><a href="#配置约定" class="headerlink" title="配置约定"></a>配置约定</h2><p>虽然IOC组件可以使我们不用手动地管理类和他们之间的依赖关系，但是我们还是需要通过配置的方式来使IOC组件根据我们的需要去管理所有的类，所以首先得约定好如何进行配置来使我们的需求被IOC组件识别，这里为了简单实现选择注解这个配置方式</p>
<ul>
<li>把当前类加入容器的注解@Bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为实例变量注入依赖的注解@Autowired</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类扫描器"><a href="#类扫描器" class="headerlink" title="类扫描器"></a>类扫描器</h2><p>在实现容器之前，我们需要拿到项目中所有的类，为了后面创建容器时能从这些类中获取带有@Bean注解的类加入容器。我们首先用ClassLoader类的getResources()方法获取包的根文件夹下的资源，然后根据这些资源是文件还是Jar包对资源做对应的处理，如果是文件就是树状读取，使用递归的方式获取文件下所有类的全类名，如果使Jar包就进行解析操作，然后迭代获取Jar包中的所有类的全类名，根据拿到的全类名通过反射的方式拿到所有类的Class对象存入list后最后返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassScanner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;?&gt;&gt; getClassList() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 除了第一次都不要需要扫描，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; classList = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Enumeration&lt;URL&gt; urls = loader.getResources(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            String protocol = url.getProtocol();</span><br><span class="line">            <span class="keyword">if</span> (protocol.equals(<span class="string">"file"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 在class目录中</span></span><br><span class="line">                String packagePath = url.getPath();</span><br><span class="line">                <span class="comment">// 执行添加类操作</span></span><br><span class="line">                addClass(classList, packageName, packagePath);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"jar"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 在jar包中</span></span><br><span class="line">                JarURLConnection jarURLConnection = (JarURLConnection) url.openConnection();</span><br><span class="line">                JarFile jarFile = jarURLConnection.getJarFile();</span><br><span class="line">                Enumeration&lt;JarEntry&gt; jarEntries = jarFile.entries();</span><br><span class="line">                <span class="keyword">while</span> (jarEntries.hasMoreElements()) &#123;</span><br><span class="line">                    JarEntry jarEntry = jarEntries.nextElement();</span><br><span class="line">                    String jarEntryName = jarEntry.getName();</span><br><span class="line">                    <span class="comment">// 判断entry是否为class</span></span><br><span class="line">                    <span class="keyword">if</span> (jarEntryName.endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 获取类名</span></span><br><span class="line">                        String className = jarEntryName.substring(<span class="number">0</span>, jarEntryName.lastIndexOf(<span class="string">"."</span>)).replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">                        <span class="comment">// 执行添加类操作</span></span><br><span class="line">                        addClass(classList, className);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扫描完成后保存list</span></span><br><span class="line">        <span class="keyword">this</span>.list = classList;</span><br><span class="line">        <span class="keyword">return</span> classList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getClassBySuper(Class&lt;?&gt; superClass) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : list) &#123;</span><br><span class="line">            <span class="comment">// 如果是superClass的子类就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (superClass.isAssignableFrom(clazz) &amp;&amp; superClass != clazz) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClass</span><span class="params">(List&lt;Class&lt;?&gt;&gt; classList, <span class="keyword">final</span> String packageName, String packagePath)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只获取包路径下的class文件和目录</span></span><br><span class="line">        File[] files = <span class="keyword">new</span> File(packagePath).listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (pathname.isFile() &amp;&amp; pathname.getName().endsWith(<span class="string">".class"</span>) || pathname.isDirectory());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            String fileName = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                <span class="comment">// 文件</span></span><br><span class="line">                String className = fileName.substring(<span class="number">0</span>, fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">                className = packageName + <span class="string">"."</span> + className;</span><br><span class="line">                addClass(classList, className);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 目录</span></span><br><span class="line">                <span class="comment">// 子目录名</span></span><br><span class="line">                String subPackagePath = packagePath + <span class="string">"/"</span> + fileName;</span><br><span class="line">                <span class="comment">// 子包名</span></span><br><span class="line">                String subPackageName = packageName + <span class="string">"."</span> + fileName;</span><br><span class="line">                <span class="comment">// 递归文件夹</span></span><br><span class="line">                addClass(classList, subPackageName, subPackagePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClass</span><span class="params">(List&lt;Class&lt;?&gt;&gt; classList, String className)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">        clazz = Class.forName(className, <span class="keyword">false</span>, Thread.currentThread().getContextClassLoader());</span><br><span class="line">        classList.add(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>对于容器我们可以直接使用静态加载的方式来简单创建一个HashMap来存储需要管理的实例，通过前面实现的类扫描器拿到的所有类的Class对象并识别带有@Bean注解的类，通过反射的方式实例化这个类，最后以Class对象为key，实例对象为value存入HashMap中，创建容器完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; beanMap = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassScanner classScanner = <span class="keyword">new</span> ClassScanner();</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; classList = classScanner.getClassList();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; clazz : classList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(Bean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 将有Bean注解的类实例化</span></span><br><span class="line">                    Object beanInstance = clazz.newInstance();</span><br><span class="line">                    <span class="comment">// 把创建的实例放入BeanMap中</span></span><br><span class="line">                    beanMap.put(clazz, beanInstance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把ClassScanner对象注入容器，供后续使用</span></span><br><span class="line">            beanMap.put(ClassScanner<span class="class">.<span class="keyword">class</span>, <span class="title">classScanner</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"容器创建出现错误"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!beanMap.containsKey(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"容器中没有此实例"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) beanMap.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> beanMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>实现容器后类的创建已经不用我们来考虑了，我们只需要实现依赖注入就完成实现IOC组件的最后一步了。为了简单实现，还是使用静态加载的方式实现这个功能。获取容器中所有Bean，然后找到Bean中带有@Aotuwired注解的字段，然后通过反射的方式进行字段注入。而且需要考虑一种比较特殊的情况，就是如果需要依赖注入的字段为接口时，我们需要去找到接口的实现类再进行注入，前面实现的类扫描器也提供了获取接口实现类的方法，使用反射的API判断得到接口的实现类，简单实现拿到第一个实现类就返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInjection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;Class&lt;?&gt;, Object&gt; beanMap = ApplicationContext.getBeanMap();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123;</span><br><span class="line">                <span class="comment">// 获取Bean的Class对象和实例</span></span><br><span class="line">                Class&lt;?&gt; beanClass = beanEntry.getKey();</span><br><span class="line">                Object beanInstance = beanEntry.getValue();</span><br><span class="line">                <span class="comment">// 获取Bean中的所有字段</span></span><br><span class="line">                Field[] fields = beanClass.getDeclaredFields();</span><br><span class="line">                <span class="keyword">if</span> (ArrayUtils.isNotEmpty(fields)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                        <span class="comment">// 找到带有Autowired注解的字段执行注入操作</span></span><br><span class="line">                        <span class="keyword">if</span> (field.isAnnotationPresent(Autowired<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                            <span class="comment">// 获取字段的Class对象</span></span><br><span class="line">                            Class&lt;?&gt; clazz = field.getType();</span><br><span class="line">                            <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                                <span class="comment">// 获取字段对应的实现类</span></span><br><span class="line">                                Class&lt;?&gt; implClass = getImpl(clazz);</span><br><span class="line">                                <span class="comment">// 获取注入对象</span></span><br><span class="line">                                Object injectInstance = beanMap.get(implClass);</span><br><span class="line">                                <span class="comment">// 暴力注入</span></span><br><span class="line">                                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                                field.set(beanInstance, injectInstance);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                Object injectInstance = beanMap.get(clazz);</span><br><span class="line">                                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                                field.set(beanInstance, injectInstance);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"依赖注入出现错误"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取接口的实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getImpl(Class&lt;?&gt; superClass) &#123;</span><br><span class="line">        ClassScanner classScanner = ApplicationContext.getBean(ClassScanner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Class&lt;?&gt; implClass = classScanner.getClassBySuper(superClass);</span><br><span class="line">        <span class="keyword">if</span> (implClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> implClass;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"注入字段为没有实现类的接口"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件初始化"><a href="#组件初始化" class="headerlink" title="组件初始化"></a>组件初始化</h2><p>因为容器和DI都是静态加载实现的，所以实现组件时直接进行两次类加载就可以完成组件的初始化，需要注意的是必须先加载容器再进行依赖注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCStarter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class.forName(ApplicationContext<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        Class.forName(DependencyInjection<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>简析Spring的IOC容器机制</title>
    <url>/2020/05/29/Spring-ClassPathXmlApplicationContext/</url>
    <content><![CDATA[<h2 id="Spring的容器"><a href="#Spring的容器" class="headerlink" title="Spring的容器"></a>Spring的容器</h2><p>我们在启动Spring的时候首先得起个容器，通过xml配置文件来得到一个Spring容器是一个很常见的操作，还有两个常用的容器为FileSystemXmlApplicationContext和AnnotationConfigApplicationContext，这三个容器都实现类ApplicationContext这个接口，这个接口构造的容器，会采取立即加载和创建Bean的机制，即读取完配置文件后直接创建配置文件中配置的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:application.xml"</span>);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="容器类的继承关系"><a href="#容器类的继承关系" class="headerlink" title="容器类的继承关系"></a>容器类的继承关系</h2><p>先来看用来构造容器的接口ApplicationContext接口的子类关系图，三个常用容器实现类都处于ApplicationContext接口继承关系的底层，FileSystemXmlApplicationContext和ClassPathXmlApplicationContext为同一类，都需要xml配置文件，而AnnotationConfigApplicationContext则处于另一个分支，不需要配置文件</p>
<p><img src="/images/ApplicationContext.png" alt="Application"></p>
<p>但是ApplicationContext不是Spring容器的顶层接口，Spring容器最顶层的接口为BeanFactory，ApplicationContext也只是BeanFactory的一个子接口，BeanFactory负责生产和管理各个Bean实例，BeanFactory有三大子接口，分别为ListableBeanFactory（可以枚举工厂生产的所有Bean实例）、HierarchicalBeanFactory（实现工厂分层，可以返回父工厂）、AutowireCapableBeanFactory（实现对容器中实例的管理，负责自动装配Bean）</p>
<p><img src="/images/BeanFactory.png" alt="BeanFactory"></p>
<p>从继承关系中可以看到ApplicationContext只实现了ListableBeanFactory和HierarchicalBeanFactory，并没有实现AutowireCapableBeanFactory接口，而是在内部通过组合的方式集成了AutowireCapableBeanFactory的功能，通过简析ClassPathXmlApplicationContext实现原理就能解答这个问题，并且初步窥探Spring容器的机制</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
</search>
