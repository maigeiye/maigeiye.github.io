<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前后端分离项目中的异常处理</title>
    <url>/2020/02/20/Exception-Handling/</url>
    <content><![CDATA[<p>在前后端分离项目中，系统中的异常不适合直接传递到前端，我们可以用错误码和异常信息封装成的自定义异常类以json的形式发送到前端，前端再根据错误码指定的错误类型和错误信息对用户完成合适的提示，这篇文章就来具体说说怎么去实现这种异常处理方式</p>
<a id="more"></a>

<h2 id="通用返回模型"><a href="#通用返回模型" class="headerlink" title="通用返回模型"></a>通用返回模型</h2><p>为了方便后端向前端传送数据，我们得先实现一个适用所有场景的返回模型，这个模型包含请求的处理结果（成功与否）以及需要返回的数据模型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReturnType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表明对应请求的返回处理结果，success或fail</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// success返回对应VO的json数据，fail则返回通用的错误码格式</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(result, <span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result, String status)</span> </span>&#123;</span><br><span class="line">        CommonReturnType type = <span class="keyword">new</span> CommonReturnType();</span><br><span class="line">        type.setStatus(status);</span><br><span class="line">        type.setData(result);</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个通用返回模型用在Controller中，整个Controller层都可以用这个模型向前端发送数据，然后前端可以解析json获取这个模型，根据响应状态和响应数据完成页面的构建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回的json数据就是&#123;status:"success", data:null&#125;</span></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="业务异常模型"><a href="#业务异常模型" class="headerlink" title="业务异常模型"></a>业务异常模型</h2><p>前面我们说到需要一个用错误码和异常信息封装而成的自定义异常类，那我们可以使用装饰器模式来达到实现业务异常类并且封装业务异常类型的目的</p>
<ul>
<li>首先定义一个核心的错误接口，规范异常类的基本行为，可以获取错误码和错误信息以及覆盖原有的错误信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getErrorMsg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>然后我们实现一个继承了错误接口的枚举类来封装业务异常类型（包含错误码以及错误描述），这里只简单定义了两种通用错误，各个业务模块需要的异常类型也同样可以封装进这个枚举类以供使用，并且实现setErrorMsg方法使枚举对象能够用自定义信息覆盖原始错误信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EmBusinessError implements CommonError &#123;</span><br><span class="line">    <span class="comment">// 通用错误的错误码以及错误描述</span></span><br><span class="line">    UNKNOWN_ERROR(<span class="number">10001</span>, <span class="string">"未知错误"</span>),</span><br><span class="line">    PARAMETER_VALIDATION_ERROR(<span class="number">10002</span>, <span class="string">"参数错误"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EmBusinessError</span><span class="params">(<span class="keyword">int</span> errorCode, String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCode;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>最后我们实现业务异常类，需要实现错误接口并且继承Exception类，我们可以通过构造器直接把EmBusinessError内部的异常类型封装到业务异常类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CommonError commonError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接接收EmBusinessError用于构造业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时接收EmBusinessError和自定义错误信息并覆盖掉原本的错误信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError, String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrorMsg(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.getErrorCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.getErrorMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.setErrorMsg(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>到这里就已经简单地实现了业务异常模型，现在我们可以用前面的通用返回模型来向前端发送异常信息了，而且我们需要一个只存储了异常对象中的错误码和错误信息的Map来作为通用返回模型的数据，这样才可以过滤一些无用的信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BusinessException e = <span class="keyword">new</span> BusinessException(EmBusinessError.UNKNOWN_ERROR);</span><br><span class="line">    Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    data.put(<span class="string">"errorCode"</span>, e.getErrorCode());</span><br><span class="line">    data.put(<span class="string">"errorMsg"</span>, e.getErrorMsg());</span><br><span class="line">    <span class="comment">// 返回的json数据就是&#123;status:"success", data:&#123;errorCode:10001, errorMsg:"未知错误"&#125;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(data, <span class="string">"fail"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>虽然现在已经可以向前端发送系统的异常信息了，但是每次出现异常都需要这样去返回错误信息是真的麻烦，而且系统出现了其他异常还是会直接返回错误页面给前端，这样的结果显然是不合理的，如果可以把异常都抛出，然后实现一个全局异常处理，把异常都拦截下来，再根据不同类型的异常用通用返回模型给前端发送错误信息就好了</p>
<p>好消息是SpringBoot提供的@ControllerAdvice和@ExceptionHandler两个注解可以帮我们实现这种操作，@ExceptionHandler能实现统一处理指定的一类异常，@ControllerAdvice是一种增强的Controller，可以用于定义@ExceptionHandler方法，适用于所有@RequestMapping方法，先看一下代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统一处理所有的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">CommonReturnType</span> <span class="title">doError</span>(<span class="title">Exception</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            BusinessException businessException = (BusinessException)e;</span><br><span class="line">            data.put(<span class="string">"errorCode"</span>, businessException.getErrorCode());</span><br><span class="line">            data.put(<span class="string">"errorMsg"</span>, businessException.getErrorMsg());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> NoHandlerFoundException) &#123;</span><br><span class="line">            data.put(<span class="string">"errorCode"</span>, EmBusinessError.UNKNOWN_ERROR.getErrorCode());</span><br><span class="line">            data.put(<span class="string">"errorMsg"</span>, <span class="string">"没有找到访问路径"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.put(<span class="string">"errorCode"</span>, EmBusinessError.UNKNOWN_ERROR.getErrorCode());</span><br><span class="line">            data.put(<span class="string">"errorMsg"</span>,EmBusinessError.UNKNOWN_ERROR.getErrorMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(data, <span class="string">"fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现了一个全局异常处理类，我们不仅可以处理业务异常，还可以处理404状态的异常以及其他所有的异常，这样前端接收到的永远都是规范的错误信息，我们也就可以放心地在Controller中抛出异常了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>, method = &#123;RequestMethod.GET&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">test</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span> Integer id) <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>高并发场景下RocketMq实现Redis缓存和MySQL数据库的一致性</title>
    <url>/2020/03/03/Mq-Cache-DB-Consistency/</url>
    <content><![CDATA[<p><img src="/images/RocketMQ-Transaction.jpg" alt="RocketMQ-Transaction"></p>
]]></content>
      <categories>
        <category>Message Queue</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot自动配置原理</title>
    <url>/2020/02/11/SpringBoot-Automatic-Assembly/</url>
    <content><![CDATA[<h2 id="自动配置介绍"><a href="#自动配置介绍" class="headerlink" title="自动配置介绍"></a>自动配置介绍</h2><p>使用Spring框架时，项目中需要的组件都要在配置文件中或者配置类进行注册导入容器，而在使用Spring Boot框架时，常用的组件都不再需要手动配置才能使用，主程序启动时会自动把所有用到的组件导入容器中，如果想要修改组件的默认配置，在Spring Boot主配置文件Application.properties中配置对应的属性即可。</p>
<p>Spring Boot启动时自动导入组件是主程序中<strong>@SpringBootApplication</strong>注解实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">    <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">    @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p><strong>@SpringBootConfiguration</strong>是Spring Boot的配置类注解，内部由<strong>@Configuration</strong>标注，表明标注的类是Spring Boot的主配置类，运行此类的main方法来启动整个应用</p>
<p><strong>@EnableAutoConfiguration</strong>是开启自动配置功能的注解，内部由两个注解标注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解<strong>@AutoConfigurationPackage</strong>是自动配置组件包的注解，由<strong>@Import</strong>导入组件Registrar.class，该组件会获取主配置类所在的包路径，然后将包和子包中所有组件扫描到容器中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Registrar<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Import({EnableAutoConfigurationImportSelector.class})导入自动配置类选择器，选择器将返回所有需要的组件的自动配置类的全类名组成的数组，Import注解就会把这些自动配置类添加到容器中，这些自动配置类生效后会把对应的组件导入到容器中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// EnableAutoConfigurationImportSelector.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">       Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">       <span class="keyword">return</span> configurations;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>SpringFactoriesLoader.<strong>loadFactoryNames</strong>方法会扫描所有jar包类路径下的<strong>META-INF/spring.factories</strong>文件中获取自动配置类的全类名，然后这些自动配置类全部被导入容器，进行自动配置工作</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring-boot-autoconfigure-1.5.9.RELEASE.jar下META-INF/spring.factories</span></span><br><span class="line"><span class="comment"># Initializers</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Listeners</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span></span><br><span class="line"><span class="attr">...</span></span><br></pre></td></tr></table></figure>



<h2 id="自动配置类原理"><a href="#自动配置类原理" class="headerlink" title="自动配置类原理"></a>自动配置类原理</h2><p>Spring Boot通过@SpringBootConfiguration注解就能把项目的组件和常用组件的自动配置类都导入容器中，那么自动配置类是如何将组件导入容器的，就以<strong>HttpEncodingAutoConfiguration</strong>自动配置类为例说明一下自动配置类的原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HttpEncodingAutoConfiguration.java</span></span><br><span class="line"><span class="comment">// 表示配置类，可以给容器添加组件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//启动指定类的ConfigurationProperties功能，会将配置文件中对应的值和HttpEncodingProperties属性绑定，并把该类导入到IOC容器</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;HttpProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">// <span class="title">Spring</span>底层注解<span class="title">Conditional</span>，根据不同的条件，如果满足指定条件，整个配置类生效</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span></span></span><br><span class="line"><span class="class">// 判断当前项目有无此类</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(</span>&#123;CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">// 判断是否存在该配置（<span class="title">spring</span>.<span class="title">http</span>.<span class="title">encoding</span>.<span class="title">enabled</span>），不配置默认为<span class="title">true</span></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>,value = &#123;<span class="string">"enabled"</span>&#125;,matchIfMissing=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器注入依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器添加组件CharacterEncodingFilter，组件需要的值从properties中获取，即HttpEncodingProperties</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 容器中没有该组件就自动加载，可以自定义</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(&#123;CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">CharacterEncodingFilter</span> <span class="title">characterEncodingFilter</span>() </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>*Properties.class</strong>都是组件属性和配置文件映射的类，这些类中封装着组件能配置的属性，@EnableConfigurationProperties({HttpProperties.class})就是把配置文件中HttpEncoding组件的属性绑定到HttpProperties.class的对应属性中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从配置文件中获取指定的值bean的属性进行绑定</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
  </entry>
</search>
